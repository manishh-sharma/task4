


![VIT University Research Platform](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.001.png)

**Blockchain Technologies**

**Project Report** 

`          	        			`**TaskHarbor**

**Task Management Application**


Team Members:

Manish Kumar Sharma - 20MIC0085

Manan Aggarwal - 20MIC0087

Arpit Jain – 20MIC0125

<a name="_gjdgxs"></a>Vishal Jain – 20MIC0161

Faculty: Manoov R

**TABLE OF CONTENTS**


|**CHAPTER NO.**|**TITLE**|
| :- | :- |
|1|` `Abstract|
|2|` `Problem Statement |
|3|` `Blockchain Integration|
|4|` `Tools & Software|
|5|` `Literature survey|
|6|` `Flowchart|
|7|` `Project Breakdown|
|8|Key Features|
|9|Project Report|
|10|Application|
|11|Novelty  of the proposed work|
|12|Challenges & Limitations|
|13|Future Development & Trends|
|14|Project Implementation|
|15|Source Code|
|16|Output|
|17|Result & Discussion|
|18|Conclusion|
|19|` `References|

















**Abstract:** 

TaskHarbor is an innovative task management application designed to tackle inefficiencies and transparency issues in conventional systems. Leveraging blockchain technology, TaskHarbor ensures robust security, transparency, and efficiency in task management. Features include blockchain data security, decentralized task tracking, immutable task records, and smart contract integration. The application caters to diverse needs, from daily planning to collaborative work, offering a versatile and secure solution for individuals and organizations. TaskHarbor sets a new standard by merging task management with blockchain, providing a comprehensive and trustworthy platform for modern productivity. In response to challenges related to trust, accountability, and data security, TaskHarbor leverages the power of blockchain technology to provide a robust and versatile solution for individuals and organizations alike.

The application offers a comprehensive set of features catering to various needs, including daily journaling, personal task management, project management, daily planning, goal tracking, collaborative work, and more. By integrating blockchain technology, TaskHarbor ensures a secure, transparent, and efficient task management experience.

**Problem Statement**

Our project Taskharbor is being developed to address the inefficiencies and lack of transparency in traditional task management systems. In many existing task management platforms, users face issues related to trust, accountability, and data security.

TaskHarbor is a robust task management application that is designed to cater to your organizational needs. This project offers a comprehensive set of features to enhance task management and streamline your workflow.

TaskHarbor is versatile tools that can be used for a wide range of purposes and can help individuals and organizations stay organized and productive. Here are some different uses of apps:- Daily Journel , Personal Task Management , Project Management , Daily Planning , Goal Tracking , Shopping Lists , Note-Taking , Collaborative Work , Travel Planning , Event Planning , Budgeting , Health and Wellness etc.

**Blockchain Integration:**

TaskHarbor is developed within the scope of blockchain technology, leveraging its unique features to enhance security, transparency, and user trust:

Blockchain Data Security: All task-related data is stored securely on the blockchain, ensuring data integrity and protection from unauthorized access or tampering.

Decentralized Task Tracking: The decentralized nature of blockchain technology ensures that task data is not controlled by a central authority, enhancing user control and privacy.

Immutable Task Records: Once a task is created or updated, the data is recorded immutably on the blockchain, providing a transparent and auditable history of task-related activities.

Smart Contract Integration: Smart contracts are utilized to automate task-related actions, such as task completion verification, ensuring efficient and trustless task management.

**Tools/Software:**

**For Ethereum Blockchain Technology:**

**Smart Contract:** Self-executing contracts written in code, residing on the Ethereum blockchain, enabling trustless and automated task management in TaskHarbor.

**Solidity**: A specialized programming language for creating smart contracts on Ethereum, used to define the rules and behavior of TaskHarbor's contract interactions.

**Remix IDE**: A web-based development environment facilitating the creation, testing, and deployment of smart contracts for TaskHarbor on the Ethereum blockchain.

**MetaMask:** A browser extension and wallet serving as the gateway for TaskHarbor users to securely manage their Ethereum-based transactions and interactions.

**Ganache:** A local blockchain emulator and development tool, providing a controlled environment for testing TaskHarbor's smart contracts and ensuring their reliability.

**For Client Side:**

**React:** A powerful JavaScript library for creating dynamic and interactive user interfaces, enabling seamless task management in TaskHarbor through responsive and engaging web components.

**HTML (Hypertext Markup Language):** The foundational markup language for structuring web pages, defining the structure and content of TaskHarbor's user interface.

**Bootstrap:** An open-source front-end framework simplifying the design of TaskHarbor's responsive and visually appealing web pages, utilizing pre-designed components for efficiency.

**JavaScript:** A versatile programming language enabling the creation of dynamic features within TaskHarbor, enhancing user interactions and content manipulation.



**For Server Side:**

**Node.js:** A runtime environment for executing server-side JavaScript code, powering TaskHarbor's backend with scalability and high performance.

**Express.js:** A minimal and flexible Node.js framework streamlining the handling of HTTP requests, routing, and middleware for TaskHarbor's web application.

**Postman:** A collaboration platform for testing TaskHarbor's API functionality, ensuring smooth and reliable communication between client and server components.



**Literature survey:** 

1. **Blockchain smart contracts: Applications, challenges, and future trends by**

**Shafaq Naheed Khan, Faiza Loukil, Chirine Ghedira-Guegan, Elhadj Benkhelifa & Anoud Bani-Hani** 

[**https://link.springer.com/article/10.1007/s12083-021-01127-0](https://link.springer.com/article/10.1007/s12083-021-01127-0)** 

This literature survey explores the impact of blockchain technology on the financial industry, emphasizing the rise of a crypto-economy and the evolution of decentralized applications facilitated by smart contracts. Despite their potential, the survey highlights persistent concerns, such as security threats and legal issues. It categorizes existing solutions, analyzes relevant research papers, and identifies challenges, paving the way for future studies to address issues and enhance the adoption of blockchain-enabled smart contracts. The survey concludes by outlining future trends in this rapidly evolving field.


1. **A systematic literature review of blockchain-based applications: Current status, classification and open issues by Fran Casino , Thomas K. Dasaklis, Constantinos Patsakis** 

   [**https://www.sciencedirect.com/science/article/pii/S0736585318306324](https://www.sciencedirect.com/science/article/pii/S0736585318306324)** 

This literature survey systematically reviews blockchain-based applications across multiple domains, aiming to understand the current state of blockchain technology and its potential to revolutionize conventional practices. The work analyzes research papers from high-ranking scientific journals over the past decade, along with reports from grey literature, providing a comprehensive classification of blockchain-enabled applications in areas like supply chain, business, healthcare, IoT, privacy, and data management. The survey identifies key themes, trends, and emerging research areas while highlighting limitations and gaps in current literature. The findings offer valuable insights for both academics and practitioners, paving the way for future exploratory directions in blockchain research.


1. **A Blockchain-based User Authentication Model Using MetaMask by Van Giang Phan Mai, Lã Minh Vũ,  Đỗ Hoàng Sơn , Nguyễn Tuấn Khải**

   [**https://www.researchgate.net/publication/370339058_A_Blockchain-based_User_Authentication_Model_Using_MetaMask](https://www.researchgate.net/publication/370339058_A_Blockchain-based_User_Authentication_Model_Using_MetaMask)** 

This paper introduces a novel authentication model designed to combat personal information takeover and theft by service providers relying on centralized servers for user authentication and personal data management. To address the centralization challenge, the proposed model leverages blockchain, a decentralized platform. This blockchain-based solution offers user authentication, dedicated information storage space, and user-specific symmetric key encryption. In practical implementation, the Ethereum public blockchain and the MetaMask web-based wallet extension are employed. Users utilize MetaMask to access the Ethereum main network through their browsers and securely deposit their encrypted personal information into a Smart Contract. The core concept revolves around the cryptographic ease of proving account ownership by signing data with a private key. In essence, this authentication model utilizes blockchain technology, specifically Ethereum, to decentralize user authentication and personal data management, enhancing security and mitigating the risks associated with centralized systems. The use of Smart Contracts ensures secure storage of encrypted personal information, providing users with greater control and ownership over their data.






1. **Security Evaluation and Improvement of Solidity Smart Contracts by Mirko Staderini, Andràs Pataricza, Andrea Bondavalli**

   [**https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4038087](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4038087)** 

This research focuses on addressing the potential security risks associated with smart contracts, which are a key innovation in the second generation of Blockchain. The automated execution of flawed contracts poses a significant threat, as smart contracts are immutable once stored on a Blockchain. This vulnerability can be exploited by attackers, leading to critical consequences, including substantial financial losses. The study specifically examines the capabilities of various static analyzers for Solidity, the primary programming language for Ethereum smart contracts.

The paper introduces a classification of 33 Solidity vulnerabilities into a language-independent taxonomy based on the Common Weakness Enumeration (CWE). It then conducts a comparative analysis of selected static analysis tools to detect these vulnerabilities within a representative set of smart contracts.

The research concludes by analyzing and prioritizing the vulnerabilities that remain uncovered. This analysis serves as a valuable indicator for developers, offering insights into the most severe vulnerabilities not addressed by existing static analysis tools. The goal is to empower developers to enhance the impact of these tools in bolstering smart contract security by focusing on the identification and mitigation of the most critical vulnerabilities.



1. **Testing Smart Contracts Using Ganache by Wei-Meng Lee**

   [**https://www.researchgate.net/publication/335657674_Testing_Smart_Contracts_Using_Ganache](https://www.researchgate.net/publication/335657674_Testing_Smart_Contracts_Using_Ganache)** 

The literature survey explores the process of testing smart contracts using Ganache, a local blockchain emulator and development tool. The focus is on understanding and implementing testing methodologies for smart contracts within the Ethereum blockchain ecosystem. Ganache, as a tool, provides a controlled environment for testing smart contracts, offering features for ease of development and testing. The survey likely delves into various aspects of testing, including functionalities such as deploying contracts, interacting with them, and assessing their behavior under different conditions.

The summary would involve insights into the testing practices recommended in the surveyed literature, potential challenges encountered during the testing process, and how Ganache is utilized to streamline and facilitate smart contract testing. It may also touch upon the advantages of using Ganache as a testing tool, such as its convenience in providing a local blockchain environment for testing without the need for real network transactions.

**Flowchart:**



**Project Breakdown:**

Our project plan provides a precise breakdown of tasks, division of work, and team members' responsibilities, ensuring a systematic approach to development. Work is evenly distributed among team members.

**Team Members and Responsibilities:**

**Arpit and Vishal:**

**Front-End Development:** Leveraging React, HTML, Bootstrap, and JavaScript, both will focus on creating a user-friendly and responsive front-end interface for TaskHarbor.

Integration: They will work closely with the backend and blockchain teams to integrate the front end seamlessly.

**Bug Fixes and Workflow:** They will test the project and address any bugs, optimize workflow processes, and refine the problem statement.

**Case Studies**: They will explore various scenarios for improvement and suggest enhancements for TaskHarbor's functionality.

**Manan:**

**Blockchain Technology:** Manan will be dedicated to work with Ethereum blockchain technologies.

**Smart Contracts:** Manan will develop smart contracts in Solidity and test using Remix IDE to ensure the secure & efficient execution of TaskHarbor's blockchain interactions.

**Blockchain Integration**: Manan will ensure smooth integration by creating APIs and connectors to link traditional databases and software with blockchain networks.

**Wallet Development:** Manan will implement secure cryptocurrency wallets for users to store and manage their digital assets using MetaMask.

**Manish:**

**Back-End Development:** Manish will lead the back-end development efforts, utilizing Node.js and Express.js to create a robust and efficient server for TaskHarbor.

**API Integration:** Manish will ensure seamless communication between the front-end and back-end components.


**Key Features:**

**Create a Task:** The core functionality of TaskHarbor revolves around task creation. Quickly add new tasks, assign names, set deadlines, and include relevant notes to maintain meticulous organization.

**Update a Task:** Easily modify task details, including descriptions, due dates, and priority levels. Adapt to changing circumstances with flexibility and precision.

**View the Task:** Access a clear and concise overview of all your tasks, including task names, due dates, and completion status. Stay informed and make informed decisions about your priorities.

**Get Status of the Task:** The "Task Status" feature provides real-time insights into task progress, helping you identify pending, in-progress, and completed tasks. Maintain a clear understanding of your project's status.

**Delete a Task:** Streamline your task list by effortlessly removing tasks that are no longer relevant. Keep your workspace organized and clutter-free by eliminating completed tasks.

**Wallet Integration:** TaskHarbor offers seamless integration with MetaMask, allowing you to monitor recent Ethereum transactions and check your Ethereum balance without leaving the application.

**Progress Report**

**Milestone 1 (Planning and Setup)**

Progress Report:

Project topic and problem statement defined: In Milestone 1, the team collectively brainstormed and finalized the project topic as "TaskHarbor - Task Management Application." The problem statement was articulated, highlighting the inefficiencies in traditional task management systems and the need for improved transparency, trust, and data security.

Team roles and responsibilities assigned: During this phase, team members were assigned specific roles and responsibilities:

Arpit and Vishal took on the role of Front-End Development. They are responsible for creating a user-friendly and responsive front-end interface for TaskHarbor.

Manan was designated as the Blockchain Technology lead, focusing on Ethereum blockchain technologies, smart contract development, and blockchain integration.

Manish assumed the role of Back-End Development, overseeing the development of a robust and efficient server for TaskHarbor, along with API integration.

Tools and software selected: The team carefully evaluated and selected the necessary tools and software for the project, ensuring compatibility and efficiency. These tools include Remix IDE, MetaMask, Ganache, React, Solidity, Node.js, Express.js, and Postman.

Initial project repository and README created: The project repository was established on a version control platform, and this README document was created to outline the project's purpose, components, and initial setup.

**Milestone 2 (Development Kickoff)**

Progress Report:

Front-end development in progress: Arpit and Vishal began the development of the front-end interface using React, HTML, Bootstrap, and JavaScript. They focused on creating a user-friendly and responsive design to ensure a seamless user experience.

Back-end server setup initiated: Manish initiated the setup of the back-end server using Node.js and Express.js. This laid the foundation for the server-side components that will enable the core functionality of TaskHarbor.

Smart contract development and testing started: Manan started developing smart contracts in Solidity, the specialized programming language for Ethereum. These smart contracts will be integral to TaskHarbor's blockchain functionality. Initial testing of smart contracts began to ensure their secure and efficient execution.

Integration planning underway: The team started planning the integration of the front-end, back-end, and blockchain components. This planning phase is crucial to ensure that all parts of TaskHarbor will work seamlessly together to deliver a robust task management application.

The project is progressing according to the defined milestones, with team members actively contributing to their respective areas of expertise. The foundations for both the front-end and back-end development are being laid, and the blockchain integration is in its early stages. The project is on track for further development and testing.

onsist of multiple layers, including convolutional layers, pooling layers, and fully connected layers, that work together to extract and process features hierarchically. 




**Applications:**

**Enterprise Task Management:**

TaskHarbor can be employed by enterprises for efficient task and project management. The blockchain integration ensures secure and transparent handling of sensitive task data, addressing trust and accountability issues often faced in large organizations.

**Healthcare Task Coordination:**

In healthcare settings, TaskHarbor's features can be adapted to coordinate tasks among healthcare professionals. The decentralized nature of the blockchain ensures the privacy and integrity of patient-related tasks, contributing to a more reliable and secure healthcare management system.

**Educational Task Planning:**

TaskHarbor can serve as a valuable tool in educational institutions for planning and tracking tasks related to curriculum development, project assignments, and collaborative research. The blockchain integration enhances data security, ensuring the integrity of academic records and task-related activities.

**Supply Chain Task Tracking:**

Within supply chain management, TaskHarbor's decentralized task tracking can be leveraged to monitor and coordinate various aspects of the supply chain process. Smart contracts can automate and streamline interactions between different entities in the supply chain, enhancing efficiency and reducing delays.

**Event Planning and Coordination:**

The application's versatility makes it suitable for event planning and coordination. Users can seamlessly manage tasks related to event organization, such as scheduling, vendor coordination, and logistics, with the added benefits of blockchain security and transparency.


**Novelty  of the proposed work:**

The proposed project, TaskHarbor, introduces a novel approach to task management by integrating blockchain technology into its core functionality. This blockchain integration adds a layer of security, transparency, and trust to the traditional task management system. Here are the key novel aspects of TaskHarbor:

**Blockchain Data Security:**

Unlike traditional task management systems that store data on centralized servers, TaskHarbor leverages blockchain for secure data storage. The decentralized nature of blockchain ensures that task-related information is stored in a tamper-proof and secure manner.

**Decentralized Task Tracking:**

TaskHarbor takes advantage of the decentralized nature of blockchain, giving users greater control and privacy over their task data. By eliminating a central authority, users can have confidence in the integrity and security of their information.

**Immutable Task Records:**

The immutability of blockchain records in TaskHarbor means that once a task is created or updated, the information is permanently recorded on the blockchain. This creates a transparent and auditable history of all task-related activities, enhancing accountability and traceability.

**Smart Contract Integration:**

The use of smart contracts in TaskHarbor automates various task-related actions, such as task completion verification. This not only streamlines the task management process but also ensures trustless interactions, reducing the need for intermediaries and enhancing overall efficiency.

By incorporating these blockchain features, TaskHarbor not only addresses common issues related to trust, accountability, and data security in traditional task management systems but also introduces a novel paradigm for task management. The application of blockchain technology to this well-studied problem provides a fresh perspective and sets TaskHarbor apart as a secure, transparent, and trustable task management solution.

**Challenges and limitations:**

**Blockchain Scalability:**

Blockchain platforms, particularly Ethereum, may face scalability issues leading to slower transaction processing times as the number of tasks and users increases.

Limitation: The scalability limitations could impact the real-time responsiveness of TaskHarbor, especially during peak usage periods, affecting user experience.

**User Adoption and Familiarity:**

Users may be unfamiliar with blockchain technology, potentially leading to resistance or hesitation in adopting TaskHarbor.

Limitation: The success of TaskHarbor may hinge on users' willingness to understand and trust the blockchain integration. Ensuring a user-friendly onboarding process and providing educational resources will be critical.

**Smart Contract Security:**

Challenge: Writing secure smart contracts is crucial to prevent vulnerabilities and attacks, and even small coding errors can have serious consequences.

Limitation: Ensuring the security of smart contracts requires rigorous auditing and testing. Any vulnerabilities could pose a risk to the integrity of task data and user information, impacting the overall reliability of TaskHarbor.


**Future developments and trends:**

In the rapidly evolving landscape of task management applications, the future development of TaskHarbor could embrace emerging trends to further enhance its capabilities. Integration with advanced artificial intelligence (AI) and machine learning (ML) algorithms could empower TaskHarbor to provide intelligent task prioritization, personalized recommendations, and predictive analytics, thereby optimizing users' workflow. Additionally, exploring interoperability with other blockchain networks beyond Ethereum may enhance scalability and offer users a choice of blockchain platforms. 

The rising importance of decentralized finance (DeFi) could also inspire the incorporation of decentralized autonomous organization (DAO) structures, enabling TaskHarbor users to participate in decision-making processes related to the application's development and governance. As the industry continues to emphasize sustainability, incorporating eco-friendly blockchain solutions or exploring alternative technologies could position TaskHarbor at the forefront of environmentally conscious task management applications. Continued adaptation to user feedback, coupled with a commitment to staying at the forefront of technological advancements, will be crucial for TaskHarbor's sustained relevance and success in the dynamic landscape of task management tools.


**Project Implementation:** 

The step-by-step instructions with the corresponding commands:

**1. Set Up Ganache:**

`   `- Download and install Ganache: [Ganache](https://www.trufflesuite.com/ganache)

`   `- Launch Ganache to create a local Ethereum test network: Open Ganache application.

**2. Add MetaMask Wallet Extension:**

`   `- Install the MetaMask wallet extension in your browser:[MetaMask](https://metamask.io/)

`   `- Connect MetaMask to the Ganache test network.

**3. Open Remix IDE:**

`   `- Access the online Remix IDE for smart contract development: [Remix  IDE] (https://remix.ethereum.org/)

**4. Connect Remix IDE to MetaMask:**

`   `- Connect Remix IDE to your MetaMask wallet: In Remix, go to the "Settings" tab and select "Solidity" under Environment. Choose "Injected Web3" for the environment.

**5. Create a Solidity File:**

`   `- In Remix IDE, create a new file named `todo.sol`.

`   `- Add Solidity code for your smart contract in `todo.sol`.

**6. Compile and Deploy:**

`   `- Compile the smart contract in Remix IDE.

`   `- Deploy the compiled smart contract to the Ganache test network.



**7. Test Transactions:**

`   `- Use Remix IDE or a tool like MyEtherWallet to interact with the deployed smart contract, testing various transactions.

**8. Set Up Node.js Server:**

`   `- Download and install Node.js: [Node.js](https://nodejs.org/)

`   `- Create a new folder named `server`: `mkdir server`

`   `- Run `npm init` inside the `server` folder to initialize a new Node.js project.

`   `- Create a file named `server.js` and add your server-side code.

**9. Use Postman for API Testing:**

`   `- Download and install Postman: [Postman](https://www.postman.com/)

`   `- Test your Node.js server APIs using Postman.

**10. Set Up React App:**

`   `- Create a new folder named `client`: `mkdir client`

`   `- Run `npx create-react-app project\_name` inside the `client` folder to set up a new React app.

`   `- Add your React app code to the generated project.

**11. Run the Project:**

`   `- In the terminal, navigate to the `server` folder: `cd server`

`   `- Run the command to start your Node.js server: `npm start`

`   `- In another terminal, navigate to the `client` folder: `cd client`

`   `- Run the command `npm start` to start your React app.

`   `- Open your browser to view the running React app.

Ensure that you run these commands in the specified directories to set up and run each component of your project successfully.

**Source Code:**

**CreateTask.jsx**

import Navigation from "./Navigate";

import { useState } from "react";

const CreateTask=({state})=>{

`    `const [modalOpen, setModalOpen] = useState(false);

`    `const [modalContent, setModalContent] = useState("");

`    `const closeModal = () => {

`        `setModalOpen(false);

`        `setModalContent("");

`      `};

`    `const createTask=async(event)=>{

event.preventDefault();

const {contract,account}=state;

const taskName=document.querySelector("#taskName").value;

const taskDate=document.querySelector("#taskDate").value;

try{

`    `const res=await fetch("http://localhost:3000/api/ethereum/create-task",{

`        `method:"POST",

`        `headers:{

`            `"content-type":"application/json"

`        `},

`        `body:JSON.stringify({ taskDate:taskDate})

`    `})

`    `const data=await res.json();

`    `console.log(data);

`    `if(data.STATUS===200)

`    `{

`        `if(contract){

`            `await contract.methods.createTask(taskName,taskDate).send({from:account})

`            `setModalContent(`Task ${taskName} added at ${taskDate}`);

`        `}}

`        `else

`        `{alert("entry can't be added")}



}

catch (error) {

`    `setModalContent(`Task already exists at ${taskDate}`);

`  `} finally {

`    `setModalOpen(true);

`  `}

`    `}

`    `return <>

`    `<Navigation/>

`    `<div className="create\_task todo\_btn">

`            `<form onSubmit={createTask}>

`              `<label>

`                `Name:

`                `<input id="taskName" />

`              `</label>

`              `<label>

`                `Date:

`                `<input id="taskDate" type="date" />

`              `</label>

`              `<button type="submit">Create Task</button>

`            `</form>

`            `{modalOpen && (

`              `<div className="modal">

`                `<div className="modal-content">

`                  `<span className="close" onClick={closeModal}>

`                    `&times;

`                  `</span>

`                  `<p>{modalContent}</p>

`                `</div>

`              `</div>

`            `)}

`            `</div>

`    `</>

}

export default CreateTask


**DeleteTask.jsx**

import Navigation from "./Navigate";

import { useState } from "react";

const DeleteTask = ({ state }) => {

`  `const [modalVisible, setModalVisible] = useState(false);

`  `const [modalContent, setModalContent] = useState("");

`  `const closeModal = () => {

`    `setModalVisible(false);

`    `setModalContent("");

`  `};


`  `const deleteTask = async (event) => {

`    `event.preventDefault();

`    `const { contract, account } = state;

`    `const taskID = document.querySelector("#taskID").value;

`    `try {

`      `const res = await fetch(`http://localhost:3000/api/ethereum/delete-task/${taskID}`, {

`        `method: "DELETE", // Correctly specify DELETE method

`        `headers: {

`          `"content-type": "application/json",

`        `},

`        `body: JSON.stringify({ taskID: taskID }),

`      `});

`      `const data = await res.json();

`      `console.log(data);

`      `if (data.STATUS === 200) {

`        `await contract.methods.deleteTask(taskID).send({ from: account });

`        `setModalContent(

`          ``Task ID ${taskID} Deleted`

`        `);

`        `setModalVisible(true);

`      `} else {

`        `alert("Entry can't be Deleted");

`      `}

`    `} catch (error) {

`      `setModalContent("Task cannot be Deleted");

`          `setModalVisible(true);

`    `}



`  `};

`  `return (

`    `<>

`      `<Navigation />

`      `<div className="delete\_task todo\_btn">

`        `<form onSubmit={deleteTask}>

`          `<label htmlFor="taskID">

`            `ID:

`            `<input id="taskID" />

`          `</label>

`          `<button type="submit">Delete entry</button>

`        `</form>

`        `{modalVisible && (

`          `<div className="modal">

`            `<div className="modal-content">

`              `<span className="close" onClick={closeModal}>

`                `&times;

`              `</span>

`              `<p>{modalContent}</p>

`            `</div>

`          `</div>

`        `)}

`      `</div>

`    `</>

`  `);

};

export default DeleteTask;



**UpdateTask.jsx**

**import { useState } from "react";**

**import Navigation from "./Navigate";**

**const UpdateTask = ({ state }) => {**

`  `**const [modalVisible, setModalVisible] = useState(false);**

`  `**const [modalContent, setModalContent] = useState("");**

`  `**const closeModal = () => {**

`    `**setModalVisible(false);**

`    `**setModalContent("");**

`  `**};**

`  `**const {contract,account}=state;**

`  `**const updateTask = async (event) => {**

`    `**event.preventDefault();**

`    `**const { contract, account } = state;**

`    `**const taskName = document.querySelector("#taskName").value;**

`    `**const taskDate = document.querySelector("#taskDate").value;**

`    `**const taskID = document.querySelector("#taskID").value;**

`    `**try {**

`      `**const res = await fetch("http://localhost:3000/api/ethereum/update-task", {**

`        `**method: "POST",**

`        `**headers: {**

`          `**"content-type": "application/json",**

`        `**},**

`        `**body: JSON.stringify({ taskID: taskID, taskName: taskName, taskDate: taskDate }), // Include taskID for updating**

`      `**});**

`      `**const data = await res.json();**

`      `**console.log(data);**

`      `**if (data.STATUS === 200 ) {**

`        `**await contract.methods.updateTask(taskID, taskName, taskDate).send({ from: account });**

`        `**setModalContent(**

`          `**`Task ID ${taskID} updated with task name ${taskName} and date ${taskDate}`**

`        `**);**

`        `**setModalVisible(true);**

`      `**} else {**

`        `**alert("Entry can't be updated");**

`      `**}**

`    `**} catch (error) {**

`      `**setModalContent("Task cannot be updated");**

`          `**setModalVisible(true);**

`    `**}**

`  `**};**

`  `**return(**

`    `**<>**

`      `**<Navigation />**

`      `**<div className="update\_task todo\_btn">**

`        `**<form onSubmit={updateTask}>**

`          `**<label>**

`            `**ID:**

`            `**<input id="taskID" />**

`          `**</label>**

`          `**<label>**

`            `**Name:**

`            `**<input id="taskName" />**

`          `**</label>**

`          `**<label>**

`            `**Date:**

`            `**<input id="taskDate" type="date" />**

`          `**</label>**

`          `**<button type="submit">Update Task</button>**

`        `**</form>**

`        `**{modalVisible && (**

`          `**<div className="modal">**

`            `**<div className="modal-content">**

`              `**<span className="close" onClick={closeModal}>**

`                `**&times;**

`              `**</span>**

`              `**<p>{modalContent}</p>**

`            `**</div>**

`          `**</div>**

`        `**)}**

`      `**</div>**

`    `**</>**

`  `**);**

**};**

**export default UpdateTask;**



**ViewAllTask.jsx**

import { useState,useEffect } from "react"

import Navigation from "./Navigate"

const ViewAllTasks=()=>{

`    `const [taskList,setTaskList]=useState([])

`    `useEffect(()=>{

`        `const allTasks=async()=>{

`        `try{

`          `const res=await fetch("http://localhost:3000/api/ethereum/view-all-task",{

`            `method:"GET",

`            `headers:{

`                `"content-type":"application/json"

`            `}

`          `})

`          `const data=await res.json();

`          `if (data.STATUS===200)

`          `{

`            `console.log(data);

`            `setTaskList(data.tasklist)

`          `}

`          `else{

`            `throw new Error;

`          `}



`        `}

`        `catch(error)

`        `{

`            `console.error(error);

`        `}

`        `}

`        `allTasks();

`    `},[])

`    `return <>

`    `<Navigation/>

`    `<div className="view\_all\_tasks">

`      `{taskList.map((task)=>{

`        `return(

`            `<div

`            `className="view\_all\_tasks\_card"

`            `key={task.tid}

`            `style={task.tid!=="" && task.name!=="" && task.date!=="" ? {} : {display:"none"}}

`            `>  

`                `<p>{task.tid}</p>

`                `<p>{task.name}</p>

`                `<p>{task.date}</p>

`            `</div>

`        `)

`      `})}

`      `</div>

`    `</>

}

export default ViewAllTasks


**Wallet.jsx**

import PropTypes from 'prop-types';

import Web3 from 'web3';

import ABI from './ABI.json';

import { useNavigate } from 'react-router-dom';

const Wallet=({saveState})=>{

`    `const navigateTo=useNavigate();

`    `const connectWallet=async()=>{

`        `try{

`            `if(window.ethereum){

`            `const web3=new Web3(window.ethereum);

`            `const accounts=await window.ethereum.request({

`                `method:"eth\_requestAccounts"

`            `})

`            `const contract\_address="0x40c4613e9428996730Bf8FEB2D7DA8c69D52D539";

`            `const contract=new web3.eth.Contract(ABI,contract\_address);

`            `saveState({web3:web3,contract:contract,account:accounts[0]});

`            `navigateTo("/view-all-tasks");

`            `}

`            `else{

`                `throw new Error;

`            `}

`        `}

`        `catch(error){

`          `console.error(error);

`        `}

`    `}

`    `return (

`        `<>

`          `<div className="wallet\_header ">

`            `<span>WELCOME TO</span> <p>TODO 3.0</p>

`          `</div>

`          `<div className="connect\_wallet\_section todo\_btn">

`            `<p> Please connect metamask wallet to access the app </p>

`            `<button onClick={connectWallet}>Connect Wallet</button>

`          `</div>

`        `</>

`      `);

}

`    `Wallet.propTypes={

`        `saveState:PropTypes.func.isRequired,

`    `};

export default Wallet





**Solidity Code(Blockchain)**

**pragma solidity ^0.8.9;**

**contract Todo{**

`    `**struct Task{**

`        `**uint id;**

`        `**string name;**

`        `**string date;**

`    `**}**

`    `**address owner;**

`    `**Task task;**

`    `**mapping(uint=>Task) tasks;**

`    `**uint taskId=1;**

`    `**modifier checkId(uint id){**

`        `**require(id!=0 && id<taskId,"Invalid Id");**

`        `**\_;**

`    `**}**

`      `**modifier checkOwner(){**

`        `**require(owner==msg.sender,"Invalid Owner");**

`        `**\_;**

`    `**}**

`    `**constructor(){**

`        `**owner=msg.sender;**

`    `**}**

`    `**function createTask(string calldata \_taskName,string calldata \_date) public {**

`        `**tasks[taskId]=Task(taskId,\_taskName,\_date);**

`        `**taskId++;**

`    `**}**

`    `**function updateTask(uint \_taskId,string calldata \_taskName,string calldata \_date) checkId(\_taskId) public**

`    `**{**

`        `**tasks[\_taskId]=Task(\_taskId,\_taskName,\_date);**

`    `**}**

`     `**function allTask() public view returns(Task[] memory){**

`         `**Task[] memory taskList=new Task[](taskId-1);**

`         `**for(uint i=0;i<taskId-1;i++)**

`         `**{**

`             `**taskList[i]=tasks[i+1];**

`         `**}**

`         `**return taskList;**

`     `**}**

`     `**function viewTask(uint \_taskId) checkId(\_taskId) public view returns(Task memory)**

`     `**{**

`         `**return tasks[\_taskId];**

`     `**}**

`     `**function deleteTask(uint \_taskId) checkId(\_taskId) public{**

`         `**delete tasks[\_taskId];**

`     `**}**

**}**

**Server.js Code:**

**const express=require('express');**

**const ABI=require('./ABI.json');**

**const cors=require("cors");**

**const {Web3}=require('web3');**

**const app=express();**

**app.use(cors())**

**app.use(express.json())**

**const web3=new Web3("HTTP://127.0.0.1:7545");                         //ganache http**

**const contract\_address="0x40c4613e9428996730Bf8FEB2D7DA8c69D52D539";  //contract address**

**const contract=new web3.eth.Contract(ABI,contract\_address);**

**const dateCheck=async(taskDate)=>{**

`    `**const tasks=await contract.methods.allTask().call();**

`    `**const foundTask=tasks.find((tasks)=>tasks.date===taskDate);**

`    `**if (foundTask) {**

`        `**return foundTask.name;**

`      `**} else {**

`        `**return "No Task Found";**

`      `**}**

**}**

**app.post("/api/ethereum/create-task",async(req,res)=>{**

`    `**const {taskDate}=req.body;**

`    `**const task=await dateCheck(taskDate);**

`    `**try{**

`     `**if(task!=="No Task Found"){**

`        `**res.status(409).json({STATUS:409,message:"Date Clashed"});**

`     `**}**

`     `**else{**

`        `**res.status(200).json({STATUS:200,message:"Entry can be Added"});**

`     `**}**

`    `**}**

`    `**catch(error)**

`    `**{**

`        `**console.error(error);**

`    `**}**

**})**

**app.post("/api/ethereum/update-task",async(req,res)=>{**

`    `**const {taskDate}=req.body;**

`    `**const task=await dateCheck(taskDate);**

`    `**try{**

`     `**if(task!=="No Task Found"){**

`        `**res.status(409).json({STATUS:409,message:"updated Date Clashed"});**

`     `**}**

`     `**else{**

`        `**res.status(200).json({STATUS:200,message:"Entry can be Updated"});**

`     `**}**

`    `**}**

`    `**catch(error)**

`    `**{**

`         `**console.error(error);**

`    `**}**

**})**

**app.get("/api/ethereum/view-task/:taskId",async(req,res)=>{**

`   `**try{**

`    `**const {taskId}=req.params;**

`    `**const task=await contract.methods.viewTask(taskId).call();**

`    `**const {id,name,date}=task;**

`    `**const tid=Number(id);**

`    `**const taskobject={**

`        `**tid,name,date**

`    `**}**

`    `**res.status(200).json({STATUS:200,taskobject,MESSAGE:"Entry Exist"});**

`   `**}**

`   `**catch(error)**

`   `**{**

`    `**res.status(404).json({STATUS:500,MESSAGE:"Entry not Exist"});**

`   `**}**

**})**

**app.get("/api/ethereum/view-all-task",async(req,res)=>{**

`    `**try{**

`     `**const task=await contract.methods.allTask().call();**

`     `**if(task.length>0)**

`   `**{**

`        `**const tasklist=task.map(({id,name,date})=>{**

`        `**const tid=Number(id);**

`        `**return {tid,name,date};**

`    `**})**

`    `**res.status(200).json({STATUS:200,tasklist,MESSAGE:"Entry Exist"});**

`   `**}**

`   `**else**

`   `**res.status(404).json({STATUS:404,tasklist,MESSAGE:"Entry List Not Exist"});**

`    `**}**

`    `**catch(error)**

`    `**{**

`       `**console.log(error);**

`    `**}**

` `**})**
**


**const priorityCheck = async(id)=>{**

`    `**const tasks = await contract.methods.allTask().call();**

`    `**const result = tasks[id-1].name.includes("priority");**

`    `**return result;**

**}**

**app.delete("/api/ethereum/delete-task/:taskId",async(req,res)=>{**

`    `**try{**

`      `**const {taskId}=req.params;**

`      `**const isTrue = await priorityCheck(taskId);**

`      `**console.log(isTrue);**

`      `**if(isTrue){**

`        `**res.status(403).json({STATUS:403,message:"Entry is prioritized"})**

`      `**}else{**

`        `**res.status(200).json({STATUS:200,message:"Entry can delete"})**

`      `**}**

`    `**}catch(error){**

`      `**console.error(error);**

`    `**}**

**})**


**app.listen(3000, function () {**

`    `**console.log("Server is running on localhost4000");**

**});**


**Output:**

![](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.002.png)

![](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.003.png)

![ref1]

![](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.005.png)

![ref1]

![](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.006.png)

![](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.007.png)

![](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.008.png)

![](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.009.png)

![](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.010.png)

![](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.011.png)

![](Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.012.png)


**Results & Discussions:**

**Results:**

**Blockchain Data Security Evaluation:**

Assess the security of task-related data stored on the blockchain.

Highlight any instances of attempted unauthorized access or tampering and how the blockchain technology successfully prevented such incidents.

**Decentralized Task Tracking:**

Discuss user feedback and experiences regarding the decentralized nature of task tracking.

Evaluate how the decentralized approach enhances user control and privacy compared to traditional centralized task management systems.

**Immutable Task Records:**

Showcase the transparency and auditability of task-related activities.

Provide examples of how the immutability of blockchain records contributes to accountability and traceability in TaskHarbor.

**Smart Contract Integration:**

Present the efficiency gains and trustless interactions achieved through smart contract automation.

Discuss user experiences with automated task-related actions and how it contributes to a more streamlined task management process.

**Discussions:**

**Comparative Analysis with Traditional Systems:**

Compare the performance and security aspects of TaskHarbor with traditional task management systems.

Discuss how blockchain integration addresses the inefficiencies and lack of transparency identified in traditional systems.


**User Trust and Adoption:**

Explore user perceptions of TaskHarbor's blockchain integration.

Discuss any challenges faced in gaining user trust and strategies employed to overcome them.

**Scalability and Performance:**

Evaluate the scalability and performance of TaskHarbor's blockchain integration.

Discuss any scalability challenges encountered and how the system copes with a growing user base.

**Future Enhancements:**

Propose potential enhancements to further improve TaskHarbor based on the results and user feedback.

Consider additional features or refinements to the blockchain integration for future iterations.

**Broader Implications:**

Discuss how the novel approach of integrating blockchain technology into task management in TaskHarbor could have broader implications for similar systems in different domains.

Consider the potential impact on data security and transparency in various applications beyond task management.

By combining the results and discussions in this manner, you can provide a comprehensive overview of the effectiveness, challenges, and future potential of TaskHarbor's unique blockchain integration in the context of task management.



**Conclusion:**

In conclusion, TaskHarbor stands as a pioneering solution in the realm of task management, addressing prevalent inefficiencies and transparency issues inherent in traditional systems. The integration of blockchain technology introduces a paradigm shift, enhancing security, transparency, and user trust. Through a robust set of features, including decentralized task tracking, immutable task records, and smart contract automation, TaskHarbor ensures a seamless and accountable task management process. The comparative analysis with traditional systems highlights the superior performance and security aspects of TaskHarbor. User trust and adoption are essential aspects discussed, acknowledging challenges faced and strategies employed to overcome them. The evaluation of scalability and performance provides insights into the system's resilience in accommodating a growing user base. Proposing future enhancements based on results and user feedback demonstrates a commitment to continuous improvement. TaskHarbor's broader implications extend beyond task management, potentially influencing data security and transparency in diverse applications. In essence, TaskHarbor not only meets current organizational needs but also sets a precedent for innovative and secure task management solutions in the ever-evolving landscape of technology.


**References**

[DappUniversity - How to Build a Blockchain App](https://www.dappuniversity.com/articles/how-to-build-a-blockchain-app)

[Flexmind - To-Do List Using Ethereum](https://www.flexmind.co/to-do-list-using-ethereum/)

[Medium - Building a ToDo Application in React and Solidity](https://medium.com/unitechie/build-todo-application-in-react-and-solidity-538ef2f1f54f)

[Ethereum - Smart Contracts](https://ethereum.org/en/developers/docs/smart-contracts/)

[101Blockchains - How to Build a Blockchain App](https://101blockchains.com/how-to-build-a-blockchain-app/)

[Klient - Problems with To-Do Lists and Project Management Software](https://klient.com/blog/5-problems-teams-have-with-to-do-lists-and-how-project-management-software-can-help/)

[Crypticera - Building a To-Do List App on Ethereum Blockchain](https://www.dappuniversity.com/articles/blockchain-app-tutorial)

[Medium - Building a ToDo App on a Blockchain using React and Hooks](https://tarun-s.medium.com/a-todo-app-on-a-blockchain-using-ethereum-using-react-and-hooks-f4a751c40793)

[ref1]: Aspose.Words.f8690d53-ffc5-4b18-9432-8e9d4fccbae9.004.png
